<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI Powered Q&A</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script>
        tailwind.config = {
            theme: {
                extend: {
                    fontFamily: {
                        sans: ['Inter', 'sans-serif'],
                    },
                    colors: {
                        cream: '#FDFCEF', // Light cream for background
                        lightOrange: '#F9B572', // Light orange for user messages
                        emeraldGreen: '#52B788', // Emerald green for AI messages and accents
                        darkEmerald: '#429A74', // Darker emerald for hover states
                        darkText: '#344E41', // Darker text for readability
                    }
                }
            }
        }
    </script>
    <style>
        /* Custom styling for a modern look */
        .chat-container {
            /* Removed fixed height constraint, now uses flex-grow */
            overflow-y: auto;
            scroll-behavior: smooth;
        }
        .message-bubble {
            max-width: 85%;
            padding: 10px 15px;
            border-radius: 20px;
            margin-bottom: 10px;
            box-shadow: 0 1px 3px 0 rgba(0, 0, 0, 0.1), 0 1px 2px 0 rgba(0, 0, 0, 0.06);
        }
        /* Using hex values here since raw CSS doesn't recognize Tailwind aliases */
        .user-message {
            background-color: #F9B572; /* lightOrange */
            color: white;
            margin-left: auto;
        }
        .ai-message {
            background-color: #52B788; /* emeraldGreen */
            color: white;
            margin-right: auto;
        }
    </style>
</head>
<!-- 1. Changed body for full screen layout and primary text color -->
<body class="bg-cream min-h-screen flex flex-col font-sans p-4 text-darkText">

    <!-- 2. Main container now fills available space (h-[95vh] or h-[90vh] on desktop) -->
    <div class="flex flex-col w-full max-w-4xl mx-auto bg-white rounded-xl shadow-2xl p-6 flex-grow h-[95vh] md:h-[90vh]">
        
        <h1 class="text-3xl font-extrabold text-darkText mb-6 text-center shrink-0">Gemini Q&A</h1>

        <!-- 3. Chat Display Area uses flex-grow to fill remaining space -->
        <div id="chat-messages" class="chat-container mb-6 rounded-lg bg-gray-50 p-4 border border-gray-200 overflow-y-auto flex-grow">
            <div class="ai-message message-bubble">Hello! Ask me anything, and I'll find an answer using Google Search.</div>
        </div>

        <!-- Input Area (shrink-0) -->
        <div class="flex space-x-3 shrink-0">
            <!-- Input text color uses darkText implicitly, border/focus uses emeraldGreen -->
            <input type="text" id="user-input" placeholder="Ask a question..." class="flex-grow p-3 border border-gray-300 rounded-full focus:ring-2 focus:ring-emeraldGreen focus:border-emeraldGreen transition duration-150" onkeydown="if(event.key === 'Enter') sendMessage()">
            <button onclick="sendMessage()" id="send-button" class="bg-emeraldGreen text-white p-3 rounded-full hover:bg-darkEmerald transition duration-150 shadow-md flex items-center justify-center">
                <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><line x1="22" y1="2" x2="11" y2="13"></line><polygon points="22 2 15 22 11 13 2 9 22 2"></polygon></svg>
            </button>
        </div>

        <!-- Loading Indicator (shrink-0) -->
        <div id="loading-indicator" class="mt-4 text-center hidden shrink-0">
            <div class="flex justify-center items-center">
                <div class="animate-spin rounded-full h-5 w-5 border-b-2 border-emeraldGreen mr-3"></div>
                <!-- Text color uses darkText inherited from parent, but here we explicitly use emeraldGreen for the spin -->
                <span class="text-emeraldGreen font-medium">Thinking...</span>
            </div>
        </div>
        
    </div>

    <script>
        // --- Gemini API Configuration ---
        // Leave apiKey as an empty string. The environment automatically provides it.
        const apiKey = "AIzaSyCsLXtp0Zm4ejBM_vymigFv_Xq9orKjr_8"; 
        const model = "gemini-2.5-flash-preview-09-2025";
        const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/${model}:generateContent?key=${apiKey}`;

        // Elements
        const chatMessages = document.getElementById('chat-messages');
        const userInput = document.getElementById('user-input');
        const sendButton = document.getElementById('send-button');
        const loadingIndicator = document.getElementById('loading-indicator');

        /**
         * The core function that uses exponential backoff to retry fetch requests.
         * @param {string} url - The API endpoint URL.
         * @param {object} options - Fetch request options (method, headers, body).
         * @param {number} maxRetries - Maximum number of retries.
         */
        async function fetchWithRetry(url, options, maxRetries = 5) {
            for (let i = 0; i < maxRetries; i++) {
                try {
                    const response = await fetch(url, options);
                    if (!response.ok) {
                        // Throw an error if the HTTP status is not 2xx
                        throw new Error(`HTTP error! status: ${response.status}`);
                    }
                    return response;
                } catch (error) {
                    console.error(`Attempt ${i + 1} failed:`, error.message);
                    if (i === maxRetries - 1) {
                        // If it's the last attempt, re-throw the original error.
                        throw new Error('All fetch attempts failed. Please check your network connection.');
                    }
                    // Exponential backoff delay (2^i seconds)
                    const delay = Math.pow(2, i) * 1000;
                    console.log(`Retrying in ${delay / 1000}s...`);
                    await new Promise(resolve => setTimeout(resolve, delay));
                }
            }
        }

        /**
         * Appends a message bubble to the chat container.
         * @param {string} text - The content of the message.
         * @param {string} sender - 'user' or 'ai'.
         * @param {string[]} [sources=[]] - Array of citation sources (only for AI messages).
         */
        function appendMessage(text, sender, sources = []) {
            const messageDiv = document.createElement('div');
            messageDiv.classList.add('message-bubble', sender === 'user' ? 'user-message' : 'ai-message');
            
            // Format text with line breaks
            messageDiv.innerHTML = text.replace(/\n/g, '<br>');

            // Append sources if available
            if (sources.length > 0) {
                const sourcesDiv = document.createElement('div');
                sourcesDiv.classList.add('text-xs', 'mt-2', 'pt-1', 'border-t', 'border-gray-200');
                
                // For AI message (emerald green bubble), links should be white/lightOrange
                const linkClass = sender === 'ai' 
                    ? 'text-white hover:text-lightOrange underline' 
                    : 'text-darkText hover:text-emeraldGreen underline'; // Fallback for user message, though unlikely to have sources

                sourcesDiv.innerHTML = '<strong>Sources:</strong><ul>' + 
                    sources.map((src, index) => 
                        `<li><a href="${src.uri}" target="_blank" class="${linkClass}">${src.title || 'Source ' + (index + 1)}</a></li>`
                    ).join('') + 
                    '</ul>';
                messageDiv.appendChild(sourcesDiv);
            }

            chatMessages.appendChild(messageDiv);
            // Scroll to bottom
            chatMessages.scrollTop = chatMessages.scrollHeight;
        }

        /**
         * Calls the Gemini API to get a grounded answer.
         * @param {string} userQuery - The question from the user.
         */
        async function getAnswer(userQuery) {
            const systemPrompt = "You are a helpful and concise assistant. Answer the user's question directly and professionally. Use the Google Search results to ground your answer.";

            const payload = {
                contents: [{ parts: [{ text: userQuery }] }],
                tools: [{ "google_search": {} }],
                systemInstruction: {
                    parts: [{ text: systemPrompt }]
                },
            };

            const options = {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(payload)
            };

            try {
                // Use the robust fetch function
                const response = await fetchWithRetry(apiUrl, options);
                const result = await response.json();

                const candidate = result.candidates?.[0];

                if (candidate && candidate.content?.parts?.[0]?.text) {
                    const text = candidate.content.parts[0].text;
                    
                    let sources = [];
                    const groundingMetadata = candidate.groundingMetadata;
                    if (groundingMetadata && groundingMetadata.groundingAttributions) {
                        sources = groundingMetadata.groundingAttributions
                            .map(attribution => ({
                                uri: attribution.web?.uri,
                                title: attribution.web?.title,
                            }))
                            .filter(source => source.uri && source.title);
                    }
                    
                    appendMessage(text, 'ai', sources);
                } else {
                    appendMessage("I apologize, I could not generate a valid response. The API might have returned an empty result.", 'ai');
                    console.error("API response missing content:", result);
                }

            } catch (error) {
                console.error("Critical API or network error:", error);
                appendMessage(`An error occurred: ${error.message}. Please check the console for details.`, 'ai');
            }
        }

        /**
         * Main function to handle user submission.
         */
        async function sendMessage() {
            const query = userInput.value.trim();
            if (!query) return;

            // Display user message
            appendMessage(query, 'user');
            userInput.value = '';

            // Disable input and show loading
            sendButton.disabled = true;
            userInput.disabled = true;
            loadingIndicator.classList.remove('hidden');

            try {
                // Get AI response
                await getAnswer(query);
            } finally {
                // Re-enable input and hide loading
                sendButton.disabled = false;
                userInput.disabled = false;
                loadingIndicator.classList.add('hidden');
                userInput.focus();
            }
        }
    </script>
</body>
</html>

